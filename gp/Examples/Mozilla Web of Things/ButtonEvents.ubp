module main
variables _useWiFi

script 345 50 {
comment 'Mozila Web of Things pushbutton example.

To test it, either press, long-press or double-press the A button
in your micro:bit and look at the display.'
}

script 745 151 {
whenStarted
defineThing 'microButton' 'PushButton'
registerEvent 'Button pressed' 'PressedEvent'
registerEvent 'Button double-pressed' 'DoublePressedEvent'
registerEvent 'Button long-pressed' 'LongPressedEvent'
}

script 52 175 {
whenCondition ('button double pressed' 'A')
sendBroadcastSimple 'Button double-pressed'
}

script 52 269 {
whenCondition ('button long pressed' 'A')
sendBroadcastSimple 'Button long-pressed'
}

script 945 340 {
whenBroadcastReceived 'Button long-pressed'
'[display:mbPlot]' 3 2
waitMillis 500
'[display:mbUnplot]' 3 2
}

script 50 364 {
whenCondition ('button pressed' 'A')
sendBroadcastSimple 'Button pressed'
}

script 633 368 {
whenBroadcastReceived 'Button double-pressed'
'[display:mbPlot]' 3 4
waitMillis 100
'[display:mbUnplot]' 3 4
waitMillis 100
'[display:mbPlot]' 3 4
waitMillis 100
'[display:mbUnplot]' 3 4
}

script 947 480 {
whenBroadcastReceived 'Button pressed'
'[display:mbPlot]' 3 3
waitMillis 100
'[display:mbUnplot]' 3 3
}


module 'Button Events'
variables _buttons

	spec ' ' '_buttonLoop' '_buttonLoop'
	spec 'r' '_read button' '_read button _' 'auto' 10
	spec 'r' 'button double pressed' 'button _ double pressed' 'auto' 'A'
	spec 'r' 'button long pressed' 'button _ long pressed' 'auto' 5
	spec 'r' 'button pressed' 'button _ pressed' 'auto' 5
	spec 'r' '_button' '_button _' 'auto' 10

to '_button' 'pin or name' {
  if (_buttons == 0) {
    _buttons = ('[data:makeList]')
    sendBroadcastSimple '_buttonLoop'
  }
  for 'each button' _buttons {
    if ((at 1 (v 'each button')) == (v 'pin or name')) {return (v 'each button')}
  }
  comment 'This button has not been initialized. Let''s add it.'
  local 'new button' ('[data:makeList]' (v 'pin or name') '' '' 'waiting')
  '[data:addLast]' (v 'new button') _buttons
  return (v 'new button')
}

to '_buttonLoop' {
  forever {
    for button _buttons {
      local 'currently pressed' ('_read button' (at 1 button))
      local 'previous state' (at 4 button)
      if (and ((v 'previous state') == 'waiting') (v 'currently pressed')) {
        comment 'save state change time'
        atPut 2 button (millisOp)
        atPut 3 button (v 'currently pressed')
        atPut 4 button 'pressed'
      } (and ((v 'previous state') == 'pressed') (not (v 'currently pressed'))) {
        local 'press time' ((millisOp) - (at 2 button))
        comment 'There''s been a press. Let''s check how long it was.'
        if ((v 'press time') > 500) {
          atPut 4 button 'long press'
        } ((v 'press time') > 250) {
          atPut 4 button 'single press'
        } else {
          comment 'This is an internal intermediate state.
It could turn out to be a single press or a double press.'
          atPut 2 button (millisOp)
          atPut 4 button 'short press'
        }
      } (and ((v 'previous state') == 'short press') (v 'currently pressed')) {
        atPut 4 button 'double press'
      } (and (and ((v 'previous state') == 'short press') (not (v 'currently pressed'))) (((millisOp) - (at 2 button)) > 250)) {
        atPut 4 button 'single press'
      } (and ((v 'previous state') == 'double press handled') (not (v 'currently pressed'))) {
        comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
        atPut 4 button 'waiting'
      }
    }
  }
}

to '_read button' 'pin or name' {
  if ((v 'pin or name') == 'A') {
    return (buttonA)
  } ((v 'pin or name') == 'B') {
    return (buttonB)
  } else {
    return (digitalReadOp (v 'pin or name'))
  }
}

to 'button double pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'double press') {
    comment 'We only go back to "waiting" after a double press if the event has been handled
and the user has released the button. Otherwise we''ll cause false "single press"
positives.'
    atPut 4 button 'double press handled'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button long pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'long press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}

to 'button pressed' 'pin or name' {
  local 'button' ('_button' (v 'pin or name'))
  local 'state' (at 4 button)
  if (state == 'single press') {
    atPut 4 button 'waiting'
    return (booleanConstant true)
  }
  return (booleanConstant false)
}


module 'LED Display' Output

	spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay'
	spec ' ' '[display:mbDisplayOff]' 'clear display'
	spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
	spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
	spec ' ' 'displayCharacter' 'display character _' 'str' 'A'

to displayCharacter s {
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}


module 'Web of Things' Comm
variables _WoT_definingEvents _useWiFi

	spec ' ' 'wifi connect to' 'wifi connect to _ password _ try _ times' 'str str num' 'Network_Name' '' 3
	spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
	spec 'r' 'getIPAddress' 'IP address'
	spec ' ' 'defineThing' 'define thing _ capability _' 'str str.thingTypesMenu' 'Hello LED' 'Light'
	spec ' ' 'registerEvent' 'register event _ type _' 'str str.thingEventTypesMenu' 'Button Pressed' 'PressedEvent'
	spec ' ' 'addBooleanProperty' 'add boolean property title _ variable _ @Type _' 'str menu.allVarsMenu str.booleanPropertyTypesMenu' '' '' 'OnOffProperty'
	spec ' ' 'addNumProp' 'add number property title _ variable _ min _ max _ @Type _' 'str menu.allVarsMenu num num str.numberPropertyTypesMenu' '' '' 0 100 'LevelProperty'
	spec ' ' 'addStringProperty' 'add string property title _ variable _ @Type _' 'str menu.allVarsMenu str.stringPropertyTypesMenu' '' '' 'ColorProperty'
	spec ' ' '_addCustomProperty' '_add to last property key _ value _' 'str auto' '' '"json value"'
	spec 'r' '[net:thingDescription]' 'thing description'
	spec ' ' '[net:clearThingDescription]' 'clear thing description'

to '_addCustomProperty' key jsonValue {
  if _useWiFi {'[net:appendToThingProperty]' '"' key '": ' jsonValue}
}

to addBooleanProperty title var typeName {
  if _useWiFi {
    '[net:appendToThingDescription]' '    "' var '": {"title": "' title '", "type": "boolean", "href": "/properties/' var '", "@type": "' typeName '"},'
  } else {
    sendBroadcast 'moz-property {"title": "' title '", "type": "boolean", "href": "/properties/' var '", "@type": "' typeName '"}'
  }
}

to addNumProp title var min max typeName {
  if _useWiFi {
    '[net:appendToThingDescription]' '    "' var '": {"title": "' title '", "type": "number", "minimum": ' min ', "maximum": ' max ', "href": "/properties/' var '", "@type": "' typeName '"'
    if ('TemperatureProperty' == typeName) {
      '[net:appendToThingDescription]' ', "unit": "degree celsius"'
    }
    '[net:appendToThingDescription]' '},'
  } else {
    sendBroadcast 'moz-property {"title":"' title '", "type": "number", "minimum": ' min ', "maximum": ' max ', "href": "/properties/' var '", "@type": "' typeName '"}'
  }
}

to addStringProperty title var typeName {
  if _useWiFi {
    '[net:appendToThingDescription]' '    "' var '": {"title": "' title '", "type": "string", "href": "/properties/' var '", "@type": "' typeName '"},'
  } else {
    sendBroadcast 'moz-property {"title":"' title '", "type": "string", "href": "/properties/' var '", "@type": "' typeName '"}'
  }
}

to defineThing name capability {
  _useWiFi = ('[net:hasWiFi]')
  if _useWiFi {
    _WoT_definingEvents = (booleanConstant false)
    '[net:clearThingDescription]'
    if ('' == capability) {
      '[net:appendToThingDescription]' '{ "title": "' name '",
  "@type": [ ],
  "links":[{
    "rel": "events",
    "href": "/events"
   }],
   "properties": {'
    } else {
      '[net:appendToThingDescription]' '{ "title": "' name '",
  "@context": "https://iot.mozilla.org/schemas/",
  "@type": ["' capability '"],
  "links":[{
    "rel": "events",
    "href": "/events"
   }],
  "properties": {'
    }
  } else {
    sendBroadcast 'moz-thing { "name": "' name '","@context": "https://iot.mozilla.org/schemas/","@type": ["' capability '"]}'
  }
}

to getIPAddress {
  return ('[net:myIPAddress]')
}

to registerEvent title type {
  if _useWiFi {
    if (not _WoT_definingEvents) {
      local 'last char' (at ((size ('[net:thingDescription]')) - 1) ('[net:thingDescription]'))
      if ((v 'last char') == '{') {
        comment 'thing description ends with "{", meaning there are no properties'
        '[net:appendToThingDescription]' '},"events":{'
      } ((v 'last char') == ',') {
        comment 'thing description ends with ",", meaning there''s at least one property'
        '[net:appendToThingDescription]' '"":{}},"events":{'
      }
      _WoT_definingEvents = (booleanConstant true)
    }
    '[net:appendToThingDescription]' '    "' title '": {"description":"MicroBlocks event", "@type":"' type '"},'
  } else {
    sendBroadcast 'moz-event {"name":"' title '", "metadata":{"description":"MicroBlocks event", "@type":"' type '"}}'
  }
}

to 'wifi connect to' ssid password tries {
  if (not ('[net:hasWiFi]')) {return}
  tries += -1
  '[net:startWiFi]' ssid password
  repeatUntil (or ('Connected' == ('[net:wifiStatus]')) (tries < 1)) {
    '[net:startWiFi]' ssid password
    repeatUntil ('Trying...' != ('[net:wifiStatus]')) {
      comment 'Slow blink while connecting'
      setUserLED true
      waitMillis 500
      setUserLED false
      waitMillis 500
    }
    tries += -1
  }
  repeat 8 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  repeatUntil ('Connected' == ('[net:wifiStatus]')) {
    comment 'Slow blink while connecting'
    setUserLED true
    waitMillis 500
    setUserLED false
    waitMillis 500
  }
  repeat 8 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

