module main
variables _bz_frequencies _bz_note_names _bz_pinNumber _loop_overhead 'ball radius' 'delta x' 'delta y' 'paddle 1 x' 'paddle 2 x' 'paddle width' playing 'refresh rate' speed x y

	spec 'r' '_bz_index of' '_bz_index of _ in _' 'auto auto any any' '10' ''
	spec ' ' 'bounce ball' 'bounce ball'
	spec ' ' 'bounce on paddle' 'bounce on paddle _' 'auto' 2
	spec ' ' 'clear ball' 'clear ball'
	spec ' ' 'freq' 'play frequency _ on pin _ for _ ms' 'auto auto auto' 440 0 '100'
	spec ' ' 'game over' 'player  _ wins' 'auto' 1
	spec ' ' 'new game' 'new game'
	spec ' ' 'plot ball' 'draw ball'
	spec ' ' 'plot paddles' 'draw paddles'

to '_bz_index of' item list {
  for i (size list) {
    if ((at i list) == item) {return i}
  }
  return 0
}

to 'bounce ball' {
  if (or (x >= (128 - ((v 'ball radius') * 2))) (x <= ((v 'ball radius') * 2))) {
    'delta x' = ((v 'delta x') * -1)
    'play tone' 'D' 1 50
  }
  if (y <= 1) {
    'game over' 1
  } (y >= 126) {
    'game over' 2
  } (and (y <= 19) (and (x >= (v 'paddle 2 x')) (x <= ((v 'paddle 2 x') + (v 'paddle width'))))) {
    'bounce on paddle' 2
  } (and (y >= 113) (and (x >= (v 'paddle 1 x')) (x <= ((v 'paddle 1 x') + (v 'paddle width'))))) {
    'bounce on paddle' 1
  }
}

to 'bounce on paddle' n {
  'delta y' = ((v 'delta y') * -1)
  local 'paddle x' 0
  if (n == 1) {
    'paddle x' = (v 'paddle 1 x')
  } else {
    'paddle x' = (v 'paddle 2 x')
  }
  if (and (x >= (v 'paddle x')) (x <= ((v 'paddle x') + 10))) {
    'delta x' = (speed * -2)
    'play tone' 'G#' 1 50
  } (and (x >= ((v 'paddle x') + ((v 'paddle width') - 10))) (x <= ((v 'paddle x') + (v 'paddle width')))) {
    'delta x' = (speed * 2)
    'play tone' 'G#' 1 50
  } ((v 'delta x') > 0) {
    'delta x' = speed
    'play tone' 'D' 1 50
  } else {
    'delta x' = (speed * -1)
    'play tone' 'D' 1 50
  }
  speed += 10
}

to 'clear ball' {
  '[tft:circle]' x y (v 'ball radius') 0 true
}

to freq freq pin ms {
  local 'initial time' (millisOp)
  local 'halfCycle' ((500000 / freq) - _loop_overhead)
  repeatUntil (((millisOp) - (v 'initial time')) > ms) {
    digitalWriteOp pin true
    waitMicros halfCycle
    digitalWriteOp pin false
    waitMicros halfCycle
  }
}

to 'game over' n {
  playing = (booleanConstant false)
  '[display:mbDisplayOff]'
  '[tft:text]' 'GAME' 18 30 (hexToInt 'FF0000') 4 false
  '[tft:text]' 'OVER' 18 70 (hexToInt 'FF0000') 4 false
  if (n == 1) {
    '[tft:text]' 'v WINNER v' 38 110 (hexToInt '00FF00') 1 false
    '[tft:line]' 40 115 40 105 (hexToInt '00FF00')
    '[tft:line]' 94 115 94 105 (hexToInt '00FF00')
  } else {
    '[tft:text]' '^ WINNER ^' 38 10 (hexToInt '00FF00') 1 false
    '[tft:line]' 40 10 40 20 (hexToInt '00FF00')
    '[tft:line]' 94 10 94 20 (hexToInt '00FF00')
  }
  'play tone' 'E' 2 150
  'play tone' 'D#' 2 150
  'play tone' 'D' 2 150
  'play tone' 'C#' 2 150
  'play tone' 'C' 2 150
  'play tone' 'B' 1 300
  waitMillis 1000
  'new game'
}

to 'new game' {
  speed = 200
  'paddle 1 x' = (random 30 80)
  'paddle 2 x' = (random 30 80)
  x = (random 30 80)
  y = 63
  if ((random 1 2) == 1) {
    'delta x' = speed
  } else {
    'delta x' = (speed * -1)
  }
  if ((random 1 2) == 1) {
    'delta y' = speed
  } else {
    'delta y' = (speed * -1)
  }
  '[display:mbDisplayOff]'
  '[tft:text]' 'PONG' 18 40 (hexToInt 'FFFF00') 4 false
  '[tft:text]' 'Press OK to start' 15 80 (hexToInt 'FFFFFF') 1 false
  waitUntil ('OK button')
  '[display:mbDisplayOff]'
  '[tft:text]' 'GO!' 30 30 (hexToInt 'FFFF00') 5 false
  waitMillis 1000
  '[display:mbDisplayOff]'
  playing = (booleanConstant true)
}

to 'plot ball' {
  '[tft:circle]' x y (v 'ball radius') (hexToInt 'FF0000') true
}

to 'plot paddles' {
  '[tft:rect]' 0 6 128 8 0 true
  '[tft:roundedRect]' (v 'paddle 2 x') 6 (v 'paddle width') 8 4 (hexToInt 'FFFF00') true
  '[tft:rect]' 0 120 128 8 0 true
  '[tft:roundedRect]' (v 'paddle 1 x') 120 (v 'paddle width') 8 4 (hexToInt 'FFFF00') true
}

script 1165 50 {
to 'bounce ball' {}
}

script 246 55 {
comment 'A rendition to one of the first videogames ever.
This one fits in your pocket!

Player 1 uses keys OK and X.
Player 2 uses ← and →.'
}

script 649 70 {
to 'new game' {}
}

script 66 122 {
whenStarted
'refresh rate' = 40
'ball radius' = 4
'paddle width' = 40
'new game'
forever {
  if playing {
    'clear ball'
    x += ((v 'delta x') / 100)
    y += ((v 'delta y') / 100)
    'plot ball'
    'bounce ball'
  }
  waitMillis (v 'refresh rate')
}
}

script 374 171 {
whenCondition ('OK button')
if ((v 'paddle 1 x') >= 4) {
  'paddle 1 x' += -2
}
'plot paddles'
}

script 384 363 {
whenCondition ('left button')
if ((v 'paddle 2 x') >= 4) {
  'paddle 2 x' += -2
}
'plot paddles'
}

script 54 587 {
whenCondition ('cancel button')
if ((v 'paddle 1 x') <= (126 - (v 'paddle width'))) {
  'paddle 1 x' += 2
}
'plot paddles'
}

script 60 772 {
whenCondition ('right button')
if ((v 'paddle 2 x') <= (126 - (v 'paddle width'))) {
  'paddle 2 x' += 2
}
'plot paddles'
}

script 1168 881 {
to 'bounce on paddle' {}
}

script 643 922 {
to 'plot ball' {}
}

script 62 951 {
to 'game over' {}
}

script 642 1061 {
to 'plot paddles' {}
}

script 631 1400 {
to 'clear ball' {}
}


module 'ED1 Buttons' Input
variables _ED1_buttons_init '_capacitive threshold' '_use capacitive'

	spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
	spec 'r' '_button pressed' '_button pressed _' 'auto any' 15
	spec 'r' '_capacitive' '_capacitive sensor _ pressed' 'auto any' 15
	spec 'r' 'OK button' 'button OK'
	spec 'r' 'cancel button' 'button X'
	spec 'r' 'up button' 'button up'
	spec 'r' 'down button' 'button down'
	spec 'r' 'left button' 'button left'
	spec 'r' 'right button' 'button right'
	spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 15
	spec ' ' 'set use capacitive to' 'set use capacitive to _' 'bool' true

to 'OK button' {
  return ('_button pressed' 15)
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    comment 'true by default for ED1 V2 board'
    '_use capacitive' = ((i2cGet (hexToInt '20') 1) == 0)
    if ((v '_capacitive threshold') == 0) {
      '_capacitive threshold' = 15
    }
    _ED1_buttons_init = (booleanConstant true)
  }
}

to '_button pressed' pin {
  '_ED1_buttons_init'
  if (v '_use capacitive') {
    return ('_capacitive' pin)
  } else {
    return (digitalReadOp pin)
  }
}

to '_capacitive' pin {
  if (('[sensors:touchRead]' pin) <= (v '_capacitive threshold')) {
    waitMicros 50
    return (('[sensors:touchRead]' pin) <= (v '_capacitive threshold'))
  } else {
    return (booleanConstant false)
  }
}

to 'cancel button' {
  return ('_button pressed' 14)
}

to 'down button' {
  return ('_button pressed' 13)
}

to 'left button' {
  return ('_button pressed' 2)
}

to 'right button' {
  return ('_button pressed' 27)
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'set use capacitive to' value {
  '_use capacitive' = value
}

to 'up button' {
  return ('_button pressed' 4)
}


module Tone Output
variables _tonePin _toneInitalized _toneLoopOverhead

	spec ' ' 'play tone' 'play note _ octave _ during _ ms' 'auto num num' 'C' 0 500
	spec ' ' 'play frequency' 'play frequency _ for _ milliseconds' 'num num' 261 500
	spec ' ' 'playMIDIKey' 'play midi key _ for _ milliseconds' 'num num' 60 500
	spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
	spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
	spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
	spec 'r' '_baseFreqForSharpOrFlat' '_baseFreqForSharpOrFlat _' 'auto' 'c#'
	spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
	spec ' ' '_toneLoop' '_toneLoop _ for _ milliseconds' 'num num' 440000 100

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  if (or (note == 'c') (note == 'C')) {
    return 261626
  } (or (note == 'd') (note == 'D')) {
    return 293665
  } (or (note == 'e') (note == 'E')) {
    return 329628
  } (or (note == 'f') (note == 'F')) {
    return 349228
  } (or (note == 'g') (note == 'G')) {
    return 391995
  } (or (note == 'a') (note == 'A')) {
    return 440000
  } (or (note == 'b') (note == 'B')) {
    return 493883
  }
  return ('_baseFreqForSharpOrFlat' note)
}

to '_baseFreqForSemitone' semitone {
  if (0 == semitone) {
    return 261626
  } (1 == semitone) {
    return 277183
  } (2 == semitone) {
    return 293665
  } (3 == semitone) {
    return 311127
  } (4 == semitone) {
    return 329628
  } (5 == semitone) {
    return 349228
  } (6 == semitone) {
    return 369994
  } (7 == semitone) {
    return 391995
  } (8 == semitone) {
    return 415305
  } (9 == semitone) {
    return 440000
  } (10 == semitone) {
    return 466164
  } (11 == semitone) {
    return 493883
  }
}

to '_baseFreqForSharpOrFlat' note {
  comment 'Return the frequency for the given sharp or flat note in the
middle-C octave scaled by 1000. Only handles black keys.
Thus, you can''t write E# to mean F.'
  if (or (or (note == 'c#') (note == 'C#')) (or (note == 'db') (note == 'Db'))) {
    return 277183
  } (or (or (note == 'd#') (note == 'D#')) (or (note == 'eb') (note == 'Eb'))) {
    return 311127
  } (or (or (note == 'f#') (note == 'F#')) (or (note == 'gb') (note == 'Gb'))) {
    return 369994
  } (or (or (note == 'g#') (note == 'G#')) (or (note == 'ab') (note == 'Ab'))) {
    return 415305
  } (or (or (note == 'a#') (note == 'A#')) (or (note == 'bb') (note == 'Bb'))) {
    return 466164
  }
  comment 'Unrecognized note names map to 0.1 Hz, which is inaudible.
This helps users find typos in their tunes.'
  return 100
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  '[display:mbDisplayOff]'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'CircuitPlayground') {
      _tonePin = 12
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } else {
      _tonePin = 0
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' (key % 12))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

