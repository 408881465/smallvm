module main
variables _bz_frequencies _bz_note_names _bz_pinNumber _loop_overhead 'current index' sequence

	spec 'r' '_bz_index of' '_bz_index of _ in _' 'auto auto any any' '10' ''
	spec ' ' '_measureLoopOverhead' '_measureLoopOverhead' 'any'
	spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
	spec 'r' 'correct guess' 'correct guess at _' 'auto' '10'
	spec ' ' 'freq' 'play frequency _ on pin _ for _ ms' 'auto auto auto' 440 0 '100'
	spec ' ' 'initialize letters' 'initialize sequence'
	spec ' ' 'play note at' 'play note at _' 'auto' '10'
	spec ' ' 'play tone' 'play note _ octave _ during _ ms' 'auto auto auto' 'G#' 3 250
	spec ' ' 'triangle up' 'draw  _' 'auto' 1
	spec 'r' 'wrong guess' 'wrong guess at _' 'auto' '10'

to '_bz_index of' item list {
  for i (size list) {
    if ((at i list) == item) {return i}
  }
  return 0
}

to '_measureLoopOverhead' {
  local 'startT' (microsOp)
  repeat 20 {
    comment 'Loop to measure timing'
    repeat 5 {
      digitalWriteOp 0 false
    }
  }
  _loop_overhead = (((microsOp) - startT) / 100)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    if ((boardType) == 'Citilab ED1') {
      _bz_pinNumber = 26
    } ((boardType) == 'CircuitPlayground') {
      _bz_pinNumber = 12
    } else {
      _bz_pinNumber = 0
    }
  } else {
    _bz_pinNumber = pinNumber
  }
  '[display:mbDisplayOff]'
  '_measureLoopOverhead'
  if (_bz_frequencies == 0) {
    _bz_frequencies = (newArray 12)
    atPut 1 _bz_frequencies 13081
    atPut 2 _bz_frequencies 13859
    atPut 3 _bz_frequencies 14683
    atPut 4 _bz_frequencies 15556
    atPut 5 _bz_frequencies 16481
    atPut 6 _bz_frequencies 17461
    atPut 7 _bz_frequencies 18500
    atPut 8 _bz_frequencies 19600
    atPut 9 _bz_frequencies 20765
    atPut 10 _bz_frequencies 22000
    atPut 11 _bz_frequencies 23308
    atPut 12 _bz_frequencies 24694
  }
  if (_bz_note_names == 0) {
    _bz_note_names = (newArray 12)
    atPut 1 _bz_note_names 'C'
    atPut 2 _bz_note_names 'C#'
    atPut 3 _bz_note_names 'D'
    atPut 4 _bz_note_names 'D#'
    atPut 5 _bz_note_names 'E'
    atPut 6 _bz_note_names 'F'
    atPut 7 _bz_note_names 'F#'
    atPut 8 _bz_note_names 'G'
    atPut 9 _bz_note_names 'G#'
    atPut 10 _bz_note_names 'A'
    atPut 11 _bz_note_names 'A#'
    atPut 12 _bz_note_names 'B'
  }
}

to 'correct guess' index {
  return (or (or (and ('up button') ((at index sequence) == 1)) (and ('down button') ((at index sequence) == 2))) (or (and ('left button') ((at index sequence) == 3)) (and ('right button') ((at index sequence) == 4))))
}

to freq freq pin ms {
  local 'initial time' (millisOp)
  local 'halfCycle' ((500000 / freq) - _loop_overhead)
  repeatUntil (((millisOp) - (v 'initial time')) > ms) {
    digitalWriteOp pin true
    waitMicros halfCycle
    digitalWriteOp pin false
    waitMicros halfCycle
  }
}

to 'initialize letters' {
  'play tone' 'C' 2 100
  'play tone' 'E' 2 100
  'play tone' 'G' 2 100
  'play tone' 'C' 3 100
  if (sequence == 0) {
    sequence = (newArray 20)
  }
  for i (size sequence) {
    atPut i sequence (random 1 4)
  }
}

to 'play note at' index {
  'triangle up' index
  if ((at index sequence) == 1) {
    'play tone' 'E' 2 200
  } ((at index sequence) == 2) {
    'play tone' 'F#' 2 200
  } ((at index sequence) == 3) {
    'play tone' 'D' 2 200
  } else {
    'play tone' 'G' 2 200
  }
}

to 'play tone' note octave ms {
  if (_bz_frequencies == 0) {'attach buzzer to pin' ''}
  local 'base frequency' (at ('_bz_index of' note _bz_note_names nil nil) _bz_frequencies)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      'base frequency' = ((v 'base frequency') / 2)
    }
  }
  repeat octave {
    'base frequency' = ((v 'base frequency') * 2)
  }
  freq ((v 'base frequency') / 100) _bz_pinNumber ms
}

to 'triangle up' index {
  '[display:mbDisplayOff]'
  if ((at index sequence) == 1) {
    '[tft:triangle]' 0 0 63 63 126 0 (hexToInt '00FF00') true
  } ((at index sequence) == 2) {
    '[tft:triangle]' 0 126 63 63 126 126 (hexToInt 'FF0000') true
  } ((at index sequence) == 3) {
    '[tft:triangle]' 0 0 63 63 0 126 (hexToInt '0000FF') true
  } else {
    '[tft:triangle]' 126 0 63 63 126 126 (hexToInt '00FFFF') true
  }
}

to 'wrong guess' index {
  return (or (or (and ('up button') ((at index sequence) != 1)) (and ('down button') ((at index sequence) != 2))) (or (and ('left button') ((at index sequence) != 3)) (and ('right button') ((at index sequence) != 4))))
}

script 96 50 {
comment 'This is the Simon memory game for the
Citilab ED1 board'
}

script 563 68 {
whenBroadcastReceived 'player turn'
local 'index' 1
repeatUntil (index > (v 'current index')) {
  if ('correct guess' index) {
    'play note at' index
    index += 1
    waitUntil (and (and (not ('up button')) (not ('down button'))) (and (not ('left button')) (not ('right button'))))
  } ('wrong guess' index) {
    'play tone' 'G' 2 250
    'play tone' 'F#' 2 250
    'play tone' 'F' 2 250
    'play tone' 'E' 2 500
    waitMillis 500
    sendBroadcastSimple 'go!'
    stopTask
  }
}
waitMillis 500
'current index' += 1
sendBroadcastSimple 'play sequence'
}

script 1119 96 {
whenBroadcastReceived 'play sequence'
if ((v 'current index') > 20) {
  'play tone' 'C' 3 100
  'play tone' 'E' 2 100
  'play tone' 'C' 3 100
  'play tone' 'E' 2 100
  'play tone' 'C' 2 100
  'play tone' 'G' 2 100
  'play tone' 'C' 3 200
  waitMillis 500
  sendBroadcastSimple 'go!'
} else {
  for i (v 'current index') {
    'play note at' i
  }
  sendBroadcastSimple 'player turn'
}
}

script 103 128 {
whenStarted
sendBroadcastSimple 'go!'
}

script 105 245 {
whenBroadcastReceived 'go!'
'current index' = 1
'initialize letters'
waitMillis 1500
sendBroadcastSimple 'play sequence'
}


module 'ED1 Buttons' Input
variables _ED1_buttons_init '_capacitive threshold' '_use capacitive'

	spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
	spec 'r' '_button pressed' '_button pressed _' 'auto any' 15
	spec 'r' '_capacitive' '_capacitive sensor _ pressed' 'auto any' 15
	spec 'r' 'OK button' 'button OK'
	spec 'r' 'cancel button' 'button X'
	spec 'r' 'up button' 'button up'
	spec 'r' 'down button' 'button down'
	spec 'r' 'left button' 'button left'
	spec 'r' 'right button' 'button right'
	spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 15
	spec ' ' 'set use capacitive to' 'set use capacitive to _' 'bool' true

to 'OK button' {
  return ('_button pressed' 15)
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    comment 'true by default for ED1 V2 board'
    '_use capacitive' = ((i2cGet (hexToInt '20') 1) == 0)
    if ((v '_capacitive threshold') == 0) {
      '_capacitive threshold' = 15
    }
    _ED1_buttons_init = (booleanConstant true)
  }
}

to '_button pressed' pin {
  '_ED1_buttons_init'
  if (v '_use capacitive') {
    return ('_capacitive' pin)
  } else {
    return (digitalReadOp pin)
  }
}

to '_capacitive' pin {
  if (('[sensors:touchRead]' pin) <= (v '_capacitive threshold')) {
    waitMicros 50
    return (('[sensors:touchRead]' pin) <= (v '_capacitive threshold'))
  } else {
    return (booleanConstant false)
  }
}

to 'cancel button' {
  return ('_button pressed' 14)
}

to 'down button' {
  return ('_button pressed' 13)
}

to 'left button' {
  return ('_button pressed' 2)
}

to 'right button' {
  return ('_button pressed' 27)
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'set use capacitive to' value {
  '_use capacitive' = value
}

to 'up button' {
  return ('_button pressed' 4)
}

