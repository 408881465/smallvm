module main
variables hours minutes seconds server

	spec ' ' 'draw time' 'draw time'
	spec ' ' 'fetch current time from server' 'fetch current time from server _' 'auto' 'microblocks.fun'
	spec 'r' 'one second after' 'one second after h _ m _ s _' 'auto auto auto' '10' '10' '10'
	spec 'r' 'online time' 'online time from server _' 'auto' 'microblocks.fun'
	spec ' ' 'tick' 'tick'

to 'draw time' {
  local 'y' (('[tft:getHeight]') / 3)
  local 'x' ((('[tft:getWidth]') - 145) / 2)
  if (x < 0) {
    x = 0
  }
  '[tft:rect]' x y 145 30 (colorSwatch 0 0 0 255)
  if (hours < 10) {
    '[tft:text]' '0' x y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' hours (x + 20) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' hours x y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 32) y (colorSwatch 255 46 18 255) 3 false
  if (minutes < 10) {
    '[tft:text]' '0' (x + 44) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' minutes (x + 64) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' minutes (x + 44) y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 76) y (colorSwatch 255 46 18 255) 3 false
  if (seconds < 10) {
    '[tft:text]' '0' (x + 88) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' seconds (x + 108) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' seconds (x + 88) y (colorSwatch 255 46 18 255) 3 false
  }
}

to 'fetch current time from server' url {
  local 'start ms' (millisOp)
  local 'current time' ('online time' url)
  hours = (('[data:copyFromTo]' (v 'current time') 1 2) + 0)
  minutes = (('[data:copyFromTo]' (v 'current time') 4 5) + 0)
  seconds = (('[data:copyFromTo]' (v 'current time') 7 8) - (((millisOp) - (v 'start ms')) / 1000))
  repeat 5 {
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 255 242 71 255) true
    waitMillis 25
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 0 0 0 255) true
    waitMillis 25
  }
}

to 'one second after' h m s {
  var += 1
}

to 'online time' url {
  local 'response' ('_request_url' url 'GET' '')
  local 'header' ('_http_header_text' response)
  return ('[data:copyFromTo]' header (('[data:find]' 'GMT' header) - 9) (('[data:find]' 'GMT' header) - 2))
}

to tick {
  seconds += 1
  if (seconds == 60) {
    seconds = 0
    minutes += 1
    if (minutes == 60) {
      minutes = 0
      hours += 1
    }
    if (hours == 24) {
      hours = 0
    }
  }
}

script 54 50 {
comment 'This project fetches the current time (GMT) from
the microblocks.fun server. It does so by parsing
the headers of the HTTP response. After that, it
keeps time by itself and requests an update from
the server every minute.

Requires a board with Wifi and a TFT display.

Remember to enter your Wifi network name and
password.'
}

script 568 80 {
whenBroadcastReceived 'time received'
forever {
  'draw time'
  tick
  waitMillis 1000
}
}

script 568 260 {
whenButtonPressed 'A'
'fetch current time from server' server
}

script 54 310 {
whenStarted
server = 'microblocks.fun'
if ((getIPAddress) == '0.0.0.0') {
  '[tft:text]' 'Connecting' 0 (('[tft:getHeight]') / 3) (colorSwatch 46 255 40 255) 2 true
  'wifi connect to' 'Network_Name' '' 3
}
'[display:mbDisplayOff]'
'[tft:text]' 'Fetching time' 0 (('[tft:getHeight]') / 5) (colorSwatch 46 255 40 255) 2 true
'[tft:text]' server 0 (('[tft:getHeight]') / 2) (colorSwatch 46 255 40 255) 2 true
'fetch current time from server' server
'[display:mbDisplayOff]'
sendBroadcastSimple 'time received'
}

script 572 365 {
whenCondition (and ((getIPAddress) != '0.0.0.0') (seconds == 0))
'fetch current time from server' server
waitUntil (seconds != 0)
}


module 'HTTP client'

	spec 'r' '_http_body_start' '_http_body_start _' 'auto' ''
	spec 'r' '_http_header_text' '_http_header_text _' 'auto' ''
	spec 'r' '_http_headers_start' '_http_headers_start _' 'auto' ''
	spec 'r' '_http_status_text' '_http_status_text _' 'auto' ''
	spec 'r' '_http_header' '_header _ of response _' 'auto auto' 'content-length' ''
	spec 'r' '_http_status' '_status of response _' 'auto' ''
	spec 'r' '_lowercase' '_lowercase _' 'auto' 'ABC Def gH'
	spec 'r' '_request_url' '_request_url _ method _ body _' 'str str str' '' 'POST' ''
	spec 'r' 'http܃//' 'http܃// _' 'auto' 'microblocks.fun/example.txt'
	spec ' ' 'request' '_ data _ to http܃// _' 'menu.requestTypes str str' 'POST' 'MicroBlocks is fun' 'postman-echo.com/post'

to '_http_body_start' response {
  return ('[data:find]' ('[data:join]' ('[data:unicodeString]' 13) ('[data:unicodeString]' 10) ('[data:unicodeString]' 13) ('[data:unicodeString]' 10)) response)
}

to '_http_header' header response {
  local 'header text' ('_http_header_text' response)
  header = ('_lowercase' header)
  repeatUntil ((size (v 'header text')) < 3) {
    local 'key' ('[data:copyFromTo]' (v 'header text') 1 (('[data:find]' ':' (v 'header text')) - 1))
    if (('_lowercase' key) == header) {
      return ('[data:copyFromTo]' (v 'header text') (('[data:find]' ':' (v 'header text')) + 2) (('[data:find]' ('[data:join]' ('[data:unicodeString]' 13) ('[data:unicodeString]' 10)) (v 'header text')) - 1))
    }
    'header text' = ('[data:copyFromTo]' (v 'header text') (('[data:find]' ('[data:join]' ('[data:unicodeString]' 13) ('[data:unicodeString]' 10)) (v 'header text')) + 2))
  }
  return (booleanConstant false)
}

to '_http_header_text' response {
  return ('[data:copyFromTo]' response ('_http_headers_start' response) (('_http_body_start' response) + 2))
}

to '_http_headers_start' response {
  return (('[data:find]' ('[data:join]' ('[data:unicodeString]' 13) ('[data:unicodeString]' 10)) response) + 2)
}

to '_http_status' response {
  return (('[data:copyFromTo]' ('_http_status_text' response) 1 4) + 0)
}

to '_http_status_text' response {
  return ('[data:copyFromTo]' response ('[data:find]' ' ' response) ('[data:find]' ('[data:join]' ('[data:unicodeString]' 13) ('[data:unicodeString]' 10)) response))
}

to '_lowercase' string {
  local 'lowercased' ''
  local 'char code' ''
  for c (size string) {
    'char code' = ('[data:unicodeAt]' c string)
    if (and ((v 'char code') >= 65) ((v 'char code') <= 90)) {
      'char code' = ((v 'char code') + 32)
    }
    lowercased = ('[data:join]' lowercased ('[data:unicodeString]' (v 'char code')))
  }
  return lowercased
}

to '_request_url' url method body {
  if (('[net:wifiStatus]') == 'Connected') {
    local 'slash position' ('[data:find]' '/' url)
    local 'request time' (millisOp)
    local 'host' ''
    local 'path' ''
    local 'chunk' ''
    local 'response' ''
    if ((v 'slash position') > 0) {
      host = ('[data:copyFromTo]' url 1 ((v 'slash position') - 1))
      path = ('[data:copyFromTo]' url ((v 'slash position') + 1))
    } else {
      host = url
    }
    '[net:httpConnect]' host
    waitUntil (or ('[net:httpIsConnected]') ((millisOp) > ((v 'request time') + 15000)))
    if ((millisOp) > ((v 'request time') + 15000)) {
      '[net:httpClose]'
      return ('[data:join]' '0 Timed out while trying to connect' ('[data:join]' ('[data:unicodeString]' 13) ('[data:unicodeString]' 10)))
    } else {
      '[net:httpRequest]' method host path body
      chunk = ('[net:httpResponse]')
      if (chunk != (booleanConstant false)) {
        response = ('[data:join]' response chunk)
      }
      repeatUntil (or (not ('[net:httpIsConnected]')) ((millisOp) > ((v 'request time') + 20000))) {
        chunk = ('[net:httpResponse]')
        if (and (chunk != (booleanConstant false)) (('[data:freeMemory]') > ((size response) * 2))) {
          response = ('[data:join]' response chunk)
        }
      }
      return response
    }
  } else {
    return ('[data:join]' '0 Not Connected' ('[data:join]' ('[data:unicodeString]' 13) ('[data:unicodeString]' 10)))
  }
}

to 'http܃//' url {
  local 'response' ('_request_url' url 'GET' '')
  if (response != '') {
    if (('_http_status' response) == 200) {
      return ('[data:copyFromTo]' response ('_http_body_start' response))
    } else {
      return ('_http_status_text' response)
    }
  } else {
    return 'Failed to get response'
  }
}

to request method data url {
  local 'response' ('_request_url' url method data)
  if (response != '') {
    sayIt ('_http_status_text' response)
  } else {
    sayIt 'Failed to get response'
  }
}


module TFT Output

	spec ' ' '[display:mbDisplayOff]' 'clear display'
	spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
	spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
	spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
	spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
	spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
	spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
	spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'auto auto color' '10' '10'
	spec 'r' 'makeColor' 'color r _ g _ b _ (0-31)' 'auto auto auto' 20 5 15
	spec 'r' 'randomColor' 'random color'
	spec 'r' '[tft:getWidth]' 'TFT width'
	spec 'r' '[tft:getHeight]' 'TFT height'
	spec ' ' '[tft:enableDisplay]' 'enable TFT _' 'bool' true

to makeColor r g b {
  return ((r << 16) | ((g << 8) | b))
}

to randomColor {
  local 'n1' (random 0 15)
  local 'n2' (random 5 20)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Tone Output
variables _tonePin _toneInitalized _toneLoopOverhead

	spec ' ' 'play tone' 'play note _ octave _ during _ ms' 'auto num num' 'C' 0 500
	spec ' ' 'play frequency' 'play frequency _ for _ milliseconds' 'num num' 261 500
	spec ' ' 'playMIDIKey' 'play midi key _ for _ milliseconds' 'num num' 60 500
	spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
	spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
	spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
	spec 'r' '_baseFreqForSharpOrFlat' '_baseFreqForSharpOrFlat _' 'auto' 'c#'
	spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
	spec ' ' '_toneLoop' '_toneLoop _ for _ milliseconds' 'num num' 440000 100

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  if (or (note == 'c') (note == 'C')) {
    return 261626
  } (or (note == 'd') (note == 'D')) {
    return 293665
  } (or (note == 'e') (note == 'E')) {
    return 329628
  } (or (note == 'f') (note == 'F')) {
    return 349228
  } (or (note == 'g') (note == 'G')) {
    return 391995
  } (or (note == 'a') (note == 'A')) {
    return 440000
  } (or (note == 'b') (note == 'B')) {
    return 493883
  }
  return ('_baseFreqForSharpOrFlat' note)
}

to '_baseFreqForSemitone' semitone {
  if (0 == semitone) {
    return 261626
  } (1 == semitone) {
    return 277183
  } (2 == semitone) {
    return 293665
  } (3 == semitone) {
    return 311127
  } (4 == semitone) {
    return 329628
  } (5 == semitone) {
    return 349228
  } (6 == semitone) {
    return 369994
  } (7 == semitone) {
    return 391995
  } (8 == semitone) {
    return 415305
  } (9 == semitone) {
    return 440000
  } (10 == semitone) {
    return 466164
  } (11 == semitone) {
    return 493883
  }
}

to '_baseFreqForSharpOrFlat' note {
  comment 'Return the frequency for the given sharp or flat note in the
middle-C octave scaled by 1000. Only handles black keys.
Thus, you can''t write E# to mean F.'
  if (or (or (note == 'c#') (note == 'C#')) (or (note == 'db') (note == 'Db'))) {
    return 277183
  } (or (or (note == 'd#') (note == 'D#')) (or (note == 'eb') (note == 'Eb'))) {
    return 311127
  } (or (or (note == 'f#') (note == 'F#')) (or (note == 'gb') (note == 'Gb'))) {
    return 369994
  } (or (or (note == 'g#') (note == 'G#')) (or (note == 'ab') (note == 'Ab'))) {
    return 415305
  } (or (or (note == 'a#') (note == 'A#')) (or (note == 'bb') (note == 'Bb'))) {
    return 466164
  }
  comment 'Unrecognized note names map to 0.1 Hz, which is inaudible.
This helps users find typos in their tunes.'
  return 100
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } else {
      _tonePin = 0
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' (key % 12))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}


module Wifi Comm

	spec ' ' 'wifi connect to' 'wifi connect to _ password _ try _ times' 'str str num' 'Network_Name' '' 3
	spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
	spec 'r' 'getIPAddress' 'IP address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to 'wifi connect to' ssid password tries {
  if (not ('[net:hasWiFi]')) {return}
  tries += -1
  '[net:startWiFi]' ssid password
  repeatUntil (or ('Connected' == ('[net:wifiStatus]')) (tries < 1)) {
    '[net:startWiFi]' ssid password
    repeatUntil ('Trying...' != ('[net:wifiStatus]')) {
      comment 'Slow blink while connecting'
      setUserLED true
      waitMillis 500
      setUserLED false
      waitMillis 500
    }
    tries += -1
  }
  repeat 8 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  repeatUntil ('Connected' == ('[net:wifiStatus]')) {
    comment 'Slow blink while connecting'
    setUserLED true
    waitMillis 500
    setUserLED false
    waitMillis 500
  }
  repeat 8 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

