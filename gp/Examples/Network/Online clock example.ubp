module main
author unknown
version 1 0 
description ''
variables hours minutes seconds server 

	spec ' ' 'draw time' 'draw time'
	spec ' ' 'fetch current time from server' 'fetch current time from server _' 'auto' 'microblocks.fun'
	spec 'r' 'online time' 'online time from server _' 'auto' 'microblocks.fun'
	spec ' ' 'tick' 'tick'

to 'draw time' {
  local 'y' (('[tft:getHeight]') / 3)
  local 'x' ((('[tft:getWidth]') - 145) / 2)
  if (x < 0) {
    x = 0
  }
  '[tft:rect]' x y 145 30 (colorSwatch 0 0 0 255)
  if (hours < 10) {
    '[tft:text]' '0' x y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' hours (x + 20) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' hours x y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 32) y (colorSwatch 255 46 18 255) 3 false
  if (minutes < 10) {
    '[tft:text]' '0' (x + 44) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' minutes (x + 64) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' minutes (x + 44) y (colorSwatch 255 46 18 255) 3 false
  }
  '[tft:text]' ':' (x + 76) y (colorSwatch 255 46 18 255) 3 false
  if (seconds < 10) {
    '[tft:text]' '0' (x + 88) y (colorSwatch 255 46 18 255) 3 false
    '[tft:text]' seconds (x + 108) y (colorSwatch 255 46 18 255) 3 false
  } else {
    '[tft:text]' seconds (x + 88) y (colorSwatch 255 46 18 255) 3 false
  }
}

to 'fetch current time from server' url {
  local 'start ms' (millisOp)
  local 'current time' ('online time' url)
  hours = (('[data:copyFromTo]' (v 'current time') 1 2) + 0)
  minutes = (('[data:copyFromTo]' (v 'current time') 4 5) + 0)
  seconds = (('[data:copyFromTo]' (v 'current time') 7 8) - (((millisOp) - (v 'start ms')) / 1000))
  repeat 5 {
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 255 242 71 255) true
    waitMillis 25
    '[tft:circle]' (('[tft:getWidth]') / 2) (('[tft:getHeight]') / 5) 5 (colorSwatch 0 0 0 255) true
    waitMillis 25
  }
}

to 'online time' url {
  local 'response' ('_request_url' url 'GET' '')
  local 'header' ('_http_header_text' response)
  return ('[data:copyFromTo]' header (('[data:find]' 'GMT' header) - 9) (('[data:find]' 'GMT' header) - 2))
}

to tick {
  seconds += 1
  if (seconds == 60) {
    seconds = 0
    minutes += 1
    if (minutes == 60) {
      minutes = 0
      hours += 1
    }
    if (hours == 24) {
      hours = 0
    }
  }
}

script 54 50 {
comment 'This project fetches the current time (GMT) from
the microblocks.fun server. It does so by parsing
the headers of the HTTP response. After that, it
keeps time by itself and requests an update from
the server every minute.

Requires a board with Wifi and a TFT display.

Remember to enter your Wifi network name and
password.'
}

script 568 80 {
whenBroadcastReceived 'time received'
forever {
  'draw time'
  tick
  waitMillis 1000
}
}

script 568 260 {
whenButtonPressed 'A'
'fetch current time from server' server
}

script 54 310 {
whenStarted
server = 'microblocks.fun'
if ((getIPAddress) == '0.0.0.0') {
  '[tft:text]' 'Connecting' 0 (('[tft:getHeight]') / 3) (colorSwatch 46 255 40 255) 2 true
  'wifi connect to' 'Network_Name' '' 3
}
'[display:mbDisplayOff]'
'[tft:text]' 'Fetching time' 0 (('[tft:getHeight]') / 5) (colorSwatch 46 255 40 255) 2 true
'[tft:text]' server 0 (('[tft:getHeight]') / 2) (colorSwatch 46 255 40 255) 2 true
'fetch current time from server' server
'[display:mbDisplayOff]'
sendBroadcast 'time received'
}

script 572 365 {
whenCondition (and ((getIPAddress) != '0.0.0.0') (seconds == 0))
'fetch current time from server' server
waitUntil (seconds != 0)
}


module 'HTTP client' Comm
author MicroBlocks
version 1 1 
depends WiFi 
tags http network get post put delete 
description 'Send HTTP requests and get responses back. You can use this library to fetch or store data in online servers, or to control other Wifi-enabled boards.
'

	spec 'r' '_http_body_start' '_http_body_start _' 'auto' ''
	spec 'r' '_http_header_text' '_http_header_text _' 'auto' ''
	spec 'r' '_http_headers_start' '_http_headers_start _' 'auto' ''
	spec 'r' '_http_status_text' '_http_status_text _' 'auto' ''
	spec 'r' '_http_header' '_header _ of response _' 'auto auto' 'content-length' ''
	spec 'r' '_http_status' '_status of response _' 'auto' ''
	spec 'r' '_line_end' '_line_end'
	spec 'r' '_lowercase' '_lowercase _' 'auto' 'ABC Def gH'
	spec 'r' '_request_url' '_request_url _ method _ body _' 'str str str' '' 'POST' ''
	spec 'r' 'http܃//' 'http܃// _' 'auto' 'microblocks.fun/example.txt'
	spec ' ' 'request' '_ data _ to http܃// _' 'menu.requestTypes str str' 'POST' 'MicroBlocks is fun' 'microblocks.fun'

to '_http_body_start' response {
  return (('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) response) + 4)
}

to '_http_header' header response {
  local 'header text' ('_http_header_text' response)
  header = ('_lowercase' header)
  repeatUntil ((size (v 'header text')) < 3) {
    local 'key' ('[data:copyFromTo]' (v 'header text') 1 (('[data:find]' ':' (v 'header text')) - 1))
    if (('_lowercase' key) == header) {
      return ('[data:copyFromTo]' (v 'header text') (('[data:find]' ':' (v 'header text')) + 2) (('[data:find]' ('_line_end') (v 'header text')) - 1))
    }
    'header text' = ('[data:copyFromTo]' (v 'header text') (('[data:find]' ('_line_end') (v 'header text')) + 2))
  }
  return (booleanConstant false)
}

to '_http_header_text' response {
  return ('[data:copyFromTo]' response ('_http_headers_start' response) (('_http_body_start' response) + 2))
}

to '_http_headers_start' response {
  return (('[data:find]' ('_line_end') response) + 2)
}

to '_http_status' response {
  return (('[data:copyFromTo]' ('_http_status_text' response) 1 4) + 0)
}

to '_http_status_text' response {
  return ('[data:copyFromTo]' response ('[data:find]' ' ' response) ('[data:find]' ('_line_end') response))
}

to '_line_end' {
  return ('[data:unicodeString]' ('[data:makeList]' 13 10))
}

to '_lowercase' string {
  local 'lowercased' ''
  local 'char code' ''
  for c (size string) {
    'char code' = ('[data:unicodeAt]' c string)
    if (and ((v 'char code') >= 65) ((v 'char code') <= 90)) {
      'char code' = ((v 'char code') + 32)
    }
    lowercased = ('[data:join]' lowercased ('[data:unicodeString]' (v 'char code')))
  }
  return lowercased
}

to '_request_url' url method body {
  local 'timeout' 20000
  local 'host' ''
  local 'path' ''
  local 'slash position' ('[data:find]' '/' url)
  if ((v 'slash position') > 0) {
    host = ('[data:copyFromTo]' url 1 ((v 'slash position') - 1))
    path = ('[data:copyFromTo]' url ((v 'slash position') + 1))
  } else {
    host = url
  }
  if (('[net:wifiStatus]') != 'Connected') {
    return ('[data:join]' '0 Not Connected' ('_line_end'))
  }
  local 'request time' (millisOp)
  comment 'Connect to the server'
  repeatUntil ('[net:httpIsConnected]') {
    '[net:httpConnect]' host
    if ((millisOp) > ((v 'request time') + timeout)) {
      return ('[data:join]' '0 Could not connect to server' ('_line_end'))
    }
  }
  comment 'Send the HTTP request'
  '[net:httpRequest]' method host path body
  comment 'Collect the response (up to 800 bytes)'
  local 'response' ''
  repeatUntil (or (not ('[net:httpIsConnected]')) ((millisOp) > ((v 'request time') + timeout))) {
    local 'chunk' ('[net:httpResponse]')
    if (((size response) + (size chunk)) <= 800) {
      response = ('[data:join]' response chunk)
    }
    waitMillis 10
  }
  return response
}

to 'http܃//' url {
  local 'response' ('_request_url' url 'GET' '')
  if (response != '') {
    if (('_http_status' response) == 200) {
      return ('[data:copyFromTo]' response ('_http_body_start' response))
    } else {
      return ('_http_status_text' response)
    }
  } else {
    return 'Failed to get response'
  }
}

to request method data url {
  local 'response' ('_request_url' url method data)
  if (response != '') {
    local 'status' ('_http_status' response)
    local 'body start' ('_http_body_start' response)
    if (and (200 == status) ((v 'body start') > 0)) {
      sayIt ('[data:copyFromTo]' response (v 'body start'))
    } else {
      sayIt ('_http_status_text' response)
    }
  } else {
    sayIt 'Failed to get response'
  }
}


module TFT Output
author MicroBlocks
version 1 1 
tags tft graphics draw 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

	spec ' ' '[display:mbDisplayOff]' 'clear display'
	spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
	spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
	spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
	spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
	spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
	spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
	spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'auto auto color' '10' '10'
	spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'auto auto auto' 0 100 100
	spec 'r' 'randomColor' 'random color'
	spec 'r' '[tft:getWidth]' 'TFT width'
	spec 'r' '[tft:getHeight]' 'TFT height'
	spec ' ' '[tft:enableDisplay]' 'enable TFT _' 'bool' true

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module WiFi Comm
author MicroBlocks
version 1 2 
tags communication network 
description 'Connect to a WiFi network. To be used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

	spec ' ' 'wifi connect to' 'wifi connect to _ password _ try _ times' 'str str num' 'Network_Name' '' 3
	spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
	spec 'r' 'getIPAddress' 'IP address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to 'wifi connect to' ssid password tries {
  if (not ('[net:hasWiFi]')) {return}
  repeatUntil (or ('Connected' == ('[net:wifiStatus]')) (tries < 1)) {
    '[net:startWiFi]' ssid password
    repeatUntil ('Trying...' != ('[net:wifiStatus]')) {
      comment 'Slow blink while connecting'
      setUserLED true
      waitMillis 500
      setUserLED false
      waitMillis 500
    }
    tries += -1
  }
  repeat 8 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  repeatUntil ('Connected' == ('[net:wifiStatus]')) {
    comment 'Slow blink while connecting'
    setUserLED true
    waitMillis 500
    setUserLED false
    waitMillis 500
  }
  repeat 8 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

