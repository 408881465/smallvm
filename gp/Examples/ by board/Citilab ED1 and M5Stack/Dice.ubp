module main
author unknown
version 1 0 
description ''

	spec ' ' 'dice' 'draw die _' 'auto' 6
	spec ' ' 'draw dot x' 'draw dot x _ y _' 'auto auto' 10 '10'

to dice num {
  '[tft:roundedRect]' 16 16 96 96 8 -1 true
  if (num <= 6) {
    if (or (or (num == 1) (num == 3)) (num == 5)) {'draw dot x' 64 64}
    if (num >= 2) {
      'draw dot x' 96 32
      'draw dot x' 32 96
    }
    if (num >= 4) {
      'draw dot x' 32 32
      'draw dot x' 96 96
    }
    if (num == 6) {
      'draw dot x' 32 64
      'draw dot x' 96 64
    }
  }
}

to 'draw dot x' x y {
  '[tft:circle]' x y 10 0 true
}

script 248 50 {
comment '    By José García Yeste - Citilab
===========================
Motion and TFT library demo.

Wait for the ED1 to say "Shake!", then
shake it to roll a die.'
}

script 50 54 {
whenStarted
repeat 12 {
  local 'ignore' (motion)
}
forever {
  '[display:mbDisplayOff]'
  dice 0
  '[tft:text]' 'Shake!' 32 56 0 2 false
  waitUntil ((motion) > 12)
  local 'tilt' 0
  repeat 10 {
    tilt = (maximum tilt (absoluteValue (motion)))
    waitMillis 30
  }
  tilt = (minimum 60 (tilt / 2))
  if (tilt > 5) {
    repeatUntil (tilt <= 0) {
      local 'delay' (('[misc:sin]' (100 * (60 - tilt))) / 100)
      dice (random 1 6)
      waitMillis delay
      'play frequency' 261 5
      tilt += -1
    }
  } else {
    dice 0
  }
  waitMillis 2000
}
}


module Motion Input
author MicroBlocks
version 1 0 
tags acceleration steps motion accelerometer 
description 'Count steps and detect motion in boards with a built-in accelerometer, such as the micro:bit, the Calliope, the Citilab ED1 or the Circuit Playground Express.'
variables _motionSamples _stepCount _stepThreshold _stepMotionHigh 

	spec ' ' 'startStepCounter' 'start step counter'
	spec 'r' 'stepCount' 'step count'
	spec ' ' 'clearStepCount' 'clear step count'
	spec ' ' 'setStepThreshold' 'set step threshold _ (0-50)' 'auto' 10
	spec 'r' 'motion' 'motion'
	spec ' ' '_addSample' '_addSample _' 'auto' '10'
	spec 'r' '_recentAverage' '_recentAverage'
	spec ' ' '_stepCounterLoop' '_stepCounterLoop'

to '_addSample' s {
  if (0 == _motionSamples) {_motionSamples = (newList 12)}
  for i ((size _motionSamples) - 1) {
    atPut i _motionSamples (at (i + 1) _motionSamples)
  }
  atPut (size _motionSamples) _motionSamples s
}

to '_recentAverage' {
  if (0 == _motionSamples) {return 0}
  local 'count' (size _motionSamples)
  local 'total' 0
  for i count {
    total += (at i _motionSamples)
  }
  return (total / count)
}

to '_stepCounterLoop' {
  if (_stepThreshold == 0) {_stepThreshold = 15}
  forever {
    local 'n' (motion)
    if (n > _stepThreshold) {
      if (not _stepMotionHigh) {
        _stepMotionHigh = (booleanConstant true)
        _stepCount += 1
        sendBroadcastSimple 'step'
      }
    } (n < -3) {
      _stepMotionHigh = (booleanConstant false)
    }
    waitMillis 10
  }
}

to clearStepCount {
  _stepCount = 0
}

to motion {
  comment 'Return the change in acceleration since the last call.'
  comment 'Details: The value is the difference between the current
acceleration and the average value of the last N samples.
The result is zero when there are no changes of acceleration.
It goes positive momentarily when the acceleration decreases
(e.g. because the microcontroller is in free fall) and positive
when the acceleration increases (e.g. when the falling micro-
controller is caught).'
  local 'current' ('[sensors:acceleration]')
  local 'result' (current - ('_recentAverage'))
  '_addSample' current
  if ((absoluteValue result) < 3) {
    comment 'Suppress sensor noise'
    result = 0
  }
  return result
}

to setStepThreshold threshold {
  comment 'The lower the threshold, the more sensitive the
step counter is. If the threshold is too low, it will
count extra steps. If it is too high, it will miss steps.'
  _stepThreshold = (threshold + 5)
}

to startStepCounter {
  comment 'Reset the step count to zero and start the
step counter loop.'
  _stepCount = 0
  sendBroadcastSimple '_stepCounterLoop'
}

to stepCount {
  return _stepCount
}


module TFT Output
author MicroBlocks
version 1 0 
tags tft graphics draw 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

	spec ' ' '[display:mbDisplayOff]' 'clear display'
	spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
	spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
	spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
	spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
	spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 5 5 nil 2 true
	spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
	spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'auto auto color' '10' '10'
	spec 'r' 'makeColor' 'color r _ g _ b _ (0-31)' 'auto auto auto' 20 5 15
	spec 'r' 'randomColor' 'random color'
	spec 'r' '[tft:getWidth]' 'TFT width'
	spec 'r' '[tft:getHeight]' 'TFT height'
	spec ' ' '[tft:enableDisplay]' 'enable TFT _' 'bool' true

to makeColor r g b {
  return ((r << 16) | ((g << 8) | b))
}

to randomColor {
  local 'n1' (random 0 15)
  local 'n2' (random 5 20)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}


module Tone Output
author MicroBlocks
version 1 1 
tags tone sound music audio note speaker 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead 

	spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'auto num num' 'C' 0 500
	spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
	spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
	spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
	spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
	spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
	spec 'r' '_baseFreqForSharpOrFlat' '_baseFreqForSharpOrFlat _' 'auto' 'c#'
	spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
	spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  if (or (note == 'c') (note == 'C')) {
    return 261626
  } (or (note == 'd') (note == 'D')) {
    return 293665
  } (or (note == 'e') (note == 'E')) {
    return 329628
  } (or (note == 'f') (note == 'F')) {
    return 349228
  } (or (note == 'g') (note == 'G')) {
    return 391995
  } (or (note == 'a') (note == 'A')) {
    return 440000
  } (or (note == 'b') (note == 'B')) {
    return 493883
  }
  return ('_baseFreqForSharpOrFlat' note)
}

to '_baseFreqForSemitone' semitone {
  if (0 == semitone) {
    return 261626
  } (1 == semitone) {
    return 277183
  } (2 == semitone) {
    return 293665
  } (3 == semitone) {
    return 311127
  } (4 == semitone) {
    return 329628
  } (5 == semitone) {
    return 349228
  } (6 == semitone) {
    return 369994
  } (7 == semitone) {
    return 391995
  } (8 == semitone) {
    return 415305
  } (9 == semitone) {
    return 440000
  } (10 == semitone) {
    return 466164
  } (11 == semitone) {
    return 493883
  }
}

to '_baseFreqForSharpOrFlat' note {
  comment 'Return the frequency for the given sharp or flat note in the
middle-C octave scaled by 1000. Only handles black keys.
Thus, you can''t write E# to mean F.'
  if (or (or (note == 'c#') (note == 'C#')) (or (note == 'db') (note == 'Db'))) {
    return 277183
  } (or (or (note == 'd#') (note == 'D#')) (or (note == 'eb') (note == 'Eb'))) {
    return 311127
  } (or (or (note == 'f#') (note == 'F#')) (or (note == 'gb') (note == 'Gb'))) {
    return 369994
  } (or (or (note == 'g#') (note == 'G#')) (or (note == 'ab') (note == 'Ab'))) {
    return 415305
  } (or (or (note == 'a#') (note == 'A#')) (or (note == 'bb') (note == 'Bb'))) {
    return 466164
  }
  comment 'Unrecognized note names map to 0.1 Hz, which is inaudible.
This helps users find typos in their tunes.'
  return 100
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } else {
      _tonePin = 0
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' (key % 12))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

