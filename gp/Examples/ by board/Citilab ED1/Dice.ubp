module main

	spec ' ' 'dice' 'draw die _' 'auto' 6
	spec ' ' 'draw dot x' 'draw dot x _ y _' 'auto auto' 10 '10'

to dice num {
  '[tft:roundedRect]' 16 16 96 96 8 -1 true
  if (num <= 6) {
    if (or (or (num == 1) (num == 3)) (num == 5)) {'draw dot x' 64 64}
    if (num >= 2) {
      'draw dot x' 96 32
      'draw dot x' 32 96
    }
    if (num >= 4) {
      'draw dot x' 32 32
      'draw dot x' 96 96
    }
    if (num == 6) {
      'draw dot x' 32 64
      'draw dot x' 96 64
    }
  }
}

to 'draw dot x' x y {
  '[tft:circle]' x y 10 0 true
}

script 160 54 {
whenStarted
repeat 12 {
  ignoreArgs (motion)
}
local 'tilt' 0
forever {
  dice 0
  '[tft:text]' 'Shake!' 32 56 0 2 false
  tilt = 0
  repeat 10 {
    tilt = (maximum tilt (absoluteValue (motion)))
    waitMillis 100
  }
  tilt = (minimum 60 tilt)
  if (tilt > 10) {
    repeatUntil (tilt <= 0) {
      local 'delay' (('[misc:sin]' (100 * (60 - tilt))) / 100)
      dice (random 1 6)
      waitMillis delay
      'play frequency' 261 5
      tilt += -1
    }
  } else {
    dice 0
  }
  waitMillis 3000
}
}

script 615 85 {
comment '    By José García Yeste - Citilab
===========================
Motion and TFT library demo.

Wait for the ED1 to say "Shake!", then
shake it to roll a die.'
}


module 'Basic Sensors' Input

	spec 'r' '[sensors:tiltX]' 'tilt x'
	spec 'r' '[sensors:tiltY]' 'tilt y'
	spec 'r' '[sensors:tiltZ]' 'tilt z'
	spec 'r' '[sensors:acceleration]' 'acceleration'
	spec 'r' '[display:lightLevel]' 'light level'
	spec 'r' '[sensors:temperature]' 'temperature (°C)'

module 'ED1 Buttons' Input
variables _ED1_buttons_init '_capacitive threshold'

	spec ' ' '_ED1_buttons_init' '_ED1_buttons_init' 'any any any'
	spec 'r' 'OK button' 'button OK'
	spec 'r' 'cancel button' 'button X'
	spec 'r' 'up button' 'button up'
	spec 'r' 'down button' 'button down'
	spec 'r' 'left button' 'button left'
	spec 'r' 'right button' 'button right'
	spec ' ' 'set capacitive threshold to' 'set capacitive threshold to _' 'auto' 16

to 'OK button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 15) < (v '_capacitive threshold'))
}

to '_ED1_buttons_init' {
  if (_ED1_buttons_init == 0) {
    if ((v '_capacitive threshold') == 0) {'_capacitive threshold' = 16}
    _ED1_buttons_init = (booleanConstant true)
  }
}

to 'cancel button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 14) < (v '_capacitive threshold'))
}

to 'down button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 13) < (v '_capacitive threshold'))
}

to 'left button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 2) < (v '_capacitive threshold'))
}

to 'right button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 27) < (v '_capacitive threshold'))
}

to 'set capacitive threshold to' threshold {
  '_capacitive threshold' = threshold
}

to 'up button' {
  '_ED1_buttons_init'
  return (('[sensors:touchRead]' 4) < (v '_capacitive threshold'))
}


module 'LED Display' Output

	spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay'
	spec ' ' '[display:mbDisplayOff]' 'clear display'
	spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
	spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
	spec ' ' 'displayCharacter' 'display character _' 'str' 'A'

to displayCharacter s {
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}


module 'Misc Primitives'

	spec ' ' 'noop' 'no op'
	spec ' ' 'ignoreArgs' 'ignore : _ : ...' 'auto' 0
	spec 'r' 'pushArgCount' 'arg count'
	spec 'r' 'getArg' 'arg _' 'num' 0
	spec 'r' 'hexToInt' 'hex _' 'str' '3F'
	spec 'r' 'longMult' '( _ * _ ) >> _' 'num num num' 1024 2048 10
	spec 'r' '[misc:sin]' 'fixed sine _' 'num' 9000

module Motion
variables _motionSamples _stepCount _stepThreshold _stepMotionHigh

	spec 'r' 'motion' 'motion'
	spec ' ' 'startStepCounter' 'start step counter'
	spec 'r' 'stepCount' 'step count'
	spec ' ' 'clearStepCount' 'clear step count'
	spec ' ' 'setStepThreshold' 'set step threshold _ (0-50)' 'auto' 10
	spec ' ' '_addSample' '_addSample _' 'auto' '10'
	spec 'r' '_recentAverage' '_recentAverage'
	spec ' ' '_stepCounterLoop' '_stepCounterLoop'

to '_addSample' s {
  if (0 == _motionSamples) {_motionSamples = (newList 12)}
  for i ((size _motionSamples) - 1) {
    atPut i _motionSamples (at (i + 1) _motionSamples)
  }
  atPut (size _motionSamples) _motionSamples s
}

to '_recentAverage' {
  if (0 == _motionSamples) {return 0}
  local 'count' (size _motionSamples)
  local 'total' 0
  for i count {
    total += (at i _motionSamples)
  }
  return (total / count)
}

to '_stepCounterLoop' {
  if (_stepThreshold == 0) {_stepThreshold = 15}
  forever {
    local 'n' (motion)
    if (n > _stepThreshold) {
      if (not _stepMotionHigh) {
        _stepMotionHigh = (booleanConstant true)
        _stepCount += 1
        sendBroadcastSimple 'step'
      }
    } (n < -3) {
      _stepMotionHigh = (booleanConstant false)
    }
    waitMillis 10
  }
}

to clearStepCount {
  _stepCount = 0
}

to motion {
  comment 'Return the change in acceleration since the last call.'
  comment 'Details: The value is the difference between the current
total acceleration in all three axes and the average value
of the last N samples. Since we don''t have a square root
function, the total acceleration is computed as the sum of
the absolute values of the acceleration in all three axes.
The result is zero when there are no changes of acceleration.
It goes positive momentarily when the acceleration decreases
(e.g. because the microcontroller is dropped) and positive
when the acceleration increases (e.g. when a falling micro-
controller is caught).'
  local 'current' (absoluteValue (maximum (absoluteValue ('[sensors:tiltX]')) (absoluteValue ('[sensors:tiltY]')) (absoluteValue ('[sensors:tiltZ]'))))
  local 'result' (current - ('_recentAverage'))
  '_addSample' current
  if ((absoluteValue result) < 3) {
    comment 'Suppress sensor noise'
    result = 0
  }
  return result
}

to setStepThreshold threshold {
  comment 'The lower the threshold, the more sensitive the
step counter is. If the threshold is too low, it will
count extra steps. If it is too high, it will miss steps.'
  _stepThreshold = (threshold + 5)
}

to startStepCounter {
  comment 'Reset the step count to zero and start the
step counter loop.'
  _stepCount = 0
  sendBroadcastSimple '_stepCounterLoop'
}

to stepCount {
  return _stepCount
}


module TFT Output

	spec ' ' '[tft:enableDisplay]' 'enable TFT _' 'bool' true
	spec ' ' '[display:mbDisplayOff]' 'clear display'
	spec 'r' '[tft:getWidth]' 'TFT width'
	spec 'r' '[tft:getHeight]' 'TFT height'
	spec ' ' 'set TFT pixel x' 'set TFT pixel x _ y _ to _' 'auto auto color' '10' '10'
	spec ' ' 'tft line' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
	spec ' ' 'tft rect' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil false
	spec ' ' 'tft roundedRect' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil false
	spec ' ' 'tft circle' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 60 100 30 nil false
	spec ' ' 'tft triangle' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil false
	spec ' ' 'tft text' 'write _ on TFT at x _ y _ color _ : scale _ wrap _' 'str num num color num bool' 'Hello World!' 0 80 nil 1 false
	spec 'r' '_tft color' '_tft color _ to number' 'color any'

to '_tft color' 'color hex' {
  local 'r' (((((v 'color hex') >> 16) & 255) * 255) / 31)
  local 'g' (((((v 'color hex') >> 8) & 255) * 255) / 31)
  local 'b' ((((v 'color hex') & 255) * 255) / 31)
  return ((r << 16) | ((g << 8) | b))
}

to 'set TFT pixel x' x y color {
  '[tft:setPixel]' x y ('_tft color' color)
}

to 'tft circle' x y radius color filled {
  '[tft:circle]' x y radius ('_tft color' color) filled
}

to 'tft line' x1 y1 x2 y2 color {
  '[tft:line]' x1 y1 x2 y2 ('_tft color' color)
}

to 'tft rect' x y w h color filled {
  '[tft:rect]' x y w h ('_tft color' color) filled
}

to 'tft roundedRect' x y w h radius color filled {
  '[tft:roundedRect]' x y w h radius ('_tft color' color) filled
}

to 'tft text' text x y color scale wrap {
  '[tft:text]' text x y ('_tft color' color) scale wrap
}

to 'tft triangle' x1 y1 x2 y2 x3 y3 color filled {
  '[tft:triangle]' x1 y1 x2 y2 x3 y3 ('_tft color' color) filled
}


module Tone Output
variables _tonePin _toneInitalized _toneLoopOverhead

	spec ' ' 'play tone' 'play note _ octave _ during _ ms' 'auto num num' 'C' 0 500
	spec ' ' 'play frequency' 'play frequency _ for _ milliseconds' 'num num' 261 500
	spec ' ' 'playMIDIKey' 'play midi key _ for _ milliseconds' 'num num' 60 500
	spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
	spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
	spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
	spec 'r' '_baseFreqForSharpOrFlat' '_baseFreqForSharpOrFlat _' 'auto' 'c#'
	spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
	spec ' ' '_toneLoop' '_toneLoop _ for _ milliseconds' 'num num' 440000 100

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  if (or (note == 'c') (note == 'C')) {
    return 261626
  } (or (note == 'd') (note == 'D')) {
    return 293665
  } (or (note == 'e') (note == 'E')) {
    return 329628
  } (or (note == 'f') (note == 'F')) {
    return 349228
  } (or (note == 'g') (note == 'G')) {
    return 391995
  } (or (note == 'a') (note == 'A')) {
    return 440000
  } (or (note == 'b') (note == 'B')) {
    return 493883
  }
  return ('_baseFreqForSharpOrFlat' note)
}

to '_baseFreqForSemitone' semitone {
  if (0 == semitone) {
    return 261626
  } (1 == semitone) {
    return 277183
  } (2 == semitone) {
    return 293665
  } (3 == semitone) {
    return 311127
  } (4 == semitone) {
    return 329628
  } (5 == semitone) {
    return 349228
  } (6 == semitone) {
    return 369994
  } (7 == semitone) {
    return 391995
  } (8 == semitone) {
    return 415305
  } (9 == semitone) {
    return 440000
  } (10 == semitone) {
    return 466164
  } (11 == semitone) {
    return 493883
  }
}

to '_baseFreqForSharpOrFlat' note {
  comment 'Return the frequency for the given sharp or flat note in the
middle-C octave scaled by 1000. Only handles black keys.
Thus, you can''t write E# to mean F.'
  if (or (or (note == 'c#') (note == 'C#')) (or (note == 'db') (note == 'Db'))) {
    return 277183
  } (or (or (note == 'd#') (note == 'D#')) (or (note == 'eb') (note == 'Eb'))) {
    return 311127
  } (or (or (note == 'f#') (note == 'F#')) (or (note == 'gb') (note == 'Gb'))) {
    return 369994
  } (or (or (note == 'g#') (note == 'G#')) (or (note == 'ab') (note == 'Ab'))) {
    return 415305
  } (or (or (note == 'a#') (note == 'A#')) (or (note == 'bb') (note == 'Bb'))) {
    return 466164
  }
  comment 'Unrecognized note names map to 0.1 Hz, which is inaudible.
This helps users find typos in their tunes.'
  return 100
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  '[display:mbDisplayOff]'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } else {
      _tonePin = 0
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' (key % 12))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

