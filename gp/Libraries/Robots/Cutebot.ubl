module Cutebot Output
author wwj718
version 1 1
depends Distance
choices channel_state '●' '◌'
choices direction left right
description 'Cutebot is a rear-drive smart car driven by dual high speed motors.

There are many on-board equipments on the Cutebot including ultrasonic sensor and distance sensor, two RGB LED headlights and clearance lamps on the bottom, two line-tracking probes, an active buzzer as the horn and so on! Let’s drive your first smart car!

ps: Cutebot can work with AILens library.

https://www.elecfreaks.com/learn-en/microbitKit/smart_cutebot/cutebot_car.html'

	spec ' ' 'set motor speed' 'Cutebot left wheel _ % right wheel  _ %' 'num num' 100 -100
	spec ' ' 'stop all motors' 'Cutebot stop wheels'
	spec 'r' 'Tracking channel' 'Cutebot tracking channel _ is _' 'menu.direction menu.channel_state' 'left' '◌'
	spec 'r' 'Tracking state is' 'Cutebot tracking state is _ _' 'menu.channel_state menu.channel_state' '◌' '◌'
	spec ' ' 'set led color' 'Cutebot set LED _ to _' 'menu.direction color' 'left'
	spec 'r' 'get distance' 'Cutebot distance (cm)'
	spec ' ' 'set servo' 'Cutebot set servo _ to _ (-100 to 100)' 'menu.range:1-2 num' 1 0
	spec 'r' '_rescale' '_rescale _ from range ( _ , _ ) to ( _ , _ )' 'num num num num num' 0 0 0 0 0

to 'Tracking channel' channel state {
  local 'pinL' 13
  local 'pinR' 14
  if (channel == 'left') {
    channel = pinL
  } else {
    channel = pinR
  }
  if (state == '●') {
    state = (booleanConstant false)
  } else {
    state = (booleanConstant true)
  }
  return ((digitalReadOp channel true) == state)
}

to 'Tracking state is' channel1_state channel2_state {
  local 'pinL' 13
  local 'pinR' 14
  if (channel1_state == '●') {
    channel1_state = (booleanConstant false)
  } else {
    channel1_state = (booleanConstant true)
  }
  if (channel2_state == '●') {
    channel2_state = (booleanConstant false)
  } else {
    channel2_state = (booleanConstant true)
  }
  return (and ((digitalReadOp pinL true) == channel1_state) ((digitalReadOp pinR false) == channel2_state))
}

to _cutebot_ADDR { return 16 }

to '_rescale' val in_min in_max out_min out_max {
  return (((val - in_min) * (out_max - out_min)) / ((in_max - in_min) + out_min))
}

to 'get distance' {
  local 'pin_e' 12
  local 'pin_t' 8
  return ('distance (cm)' pin_t pin_e)
}

to 'set led color' led_name color {
  if (led_name == 'left') {
    local 'led' (hexToInt '04')
  } else {
    local 'led' (hexToInt '08')
  }
  local 'r' ((color >> 16) & 255)
  local 'g' ((color >> 8) & 255)
  local 'b' ((color >> b) & 255)
  '[sensors:i2cWrite]' (_cutebot_ADDR) ('[data:asByteArray]' ('[data:makeList]' led r g b))
}

to 'set motor speed' left_wheel_speed right_wheel_speed {
  comment 'speed (number): -100-100'
  local 'left_direction' 0
  local 'right_direction' 0
  if (or (left_wheel_speed < -100) (left_wheel_speed > 100)) {
    left_wheel_speed = 0
  }
  if (or (right_wheel_speed < -100) (right_wheel_speed > 100)) {
    right_wheel_speed = 0
  }
  if (left_wheel_speed > 0) {
    left_direction = 2
  } else {
    left_direction = 1
    left_wheel_speed = (left_wheel_speed * -1)
  }
  if (right_wheel_speed > 0) {
    right_direction = 2
  } else {
    right_direction = 1
    right_wheel_speed = (right_wheel_speed * -1)
  }
  '[sensors:i2cWrite]' (_cutebot_ADDR) ('[data:asByteArray]' ('[data:makeList]' 1 left_direction left_wheel_speed 0))
  '[sensors:i2cWrite]' (_cutebot_ADDR) ('[data:asByteArray]' ('[data:makeList]' 2 right_direction right_wheel_speed 0))
}

to 'set servo' servo value {
  comment 'servo (number) is one of: 1 2
value range of -100 to 100 maps to the full range of the servo'

  if (or (servo < 1) (servo > 2)) {
    servo = 1
  }
  value = (maximum -100 (minimum value 100))
  '[sensors:i2cWrite]' (_cutebot_ADDR) ('[data:asByteArray]' ('[data:makeList]' (servo + 4) ('_rescale' angle -100 100 0 180) 0 0))
}

to 'stop all motors' {
  'set motor speed' 0 0
}

