module Fractions Operators
author 'MicroBlocks'
version 1 0 
tags numbers fractions precision float 
description 'Rational numbers. If you really need floats but only have integers.'

	spec 'r' 'FRACT' 'fraction _ / _' 'auto auto' 3 4
	spec 'r' 'FRACT_add' 'fract _ + _' 'auto auto' 3 4
	spec 'r' 'FRACT_subtract' 'fract _ - _' 'auto auto' 4 3
	spec 'r' 'FRACT_multiply' 'fract _ ร _' 'auto auto' 3 4
	spec 'r' 'FRACT_divide' 'fract _ รท _' 'auto auto' 3 4
	spec 'r' 'FRACT_less' 'fract _ < _' 'auto auto' 3 4
	spec 'r' 'FRACT_greater' 'fract _ > _' 'auto auto' 3 4
	spec 'r' 'FRACT_simplify' 'simplify fraction _' 'auto' 5
	spec 'r' 'FRACT_integer' 'integer part of fraction _' 'auto' 5
	spec 'r' 'FRACT_numerator' 'numerator of fraction _' 'auto' 5
	spec 'r' 'FRACT_denominator' 'denominator of fraction _' 'auto' 5
	spec 'r' 'FRACT_gcd' 'gcd _ _' 'auto auto' 9 12
	spec 'r' 'FRACT_lcm' 'lcm _ _' 'auto auto' 4 6

to FRACT numerator denominator {
  if (or (isType numerator 'list') (isType denominator 'list')) {return (FRACT_divide numerator denominator)}
  return ('[data:makeList]' numerator denominator)
}

to FRACT_add a b {
  if (isType a 'number') {a = (FRACT a 1)}
  if (isType b 'number') {b = (FRACT b 1)}
  local 'lcd' ((FRACT_denominator a) * (FRACT_denominator b))
  return (FRACT_simplify (FRACT (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) + ((FRACT_numerator b) * (lcd / (FRACT_denominator b)))) lcd))
}

to FRACT_denominator fraction {
  if (isType fraction 'number') {return 1}
  return (at 2 fraction)
}

to FRACT_divide a b {
  if (isType a 'number') {a = (FRACT a 1)}
  if (isType b 'number') {b = (FRACT b 1)}
  return (FRACT_simplify (FRACT_multiply a (FRACT (FRACT_denominator b) (FRACT_numerator b))))
}

to FRACT_gcd a b {
  repeatUntil (a == b) {
    if (a == 0) {
      return b
    } (b == 0) {
      return a
    } (a > b) {
      a += (b * -1)
    } else {
      b += (a * -1)
    }
  }
  return a
}

to FRACT_greater a b {
  if (isType a 'number') {a = (FRACT a 1)}
  if (isType b 'number') {b = (FRACT b 1)}
  local 'lcd' ((FRACT_denominator a) * (FRACT_denominator b))
  return (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) > ((FRACT_numerator b) * (lcd / (FRACT_denominator b))))
}

to FRACT_integer fraction {
  return ((FRACT_numerator fraction) / (FRACT_denominator fraction))
}

to FRACT_lcm a b {
  return ((a / (FRACT_gcd a b)) * b)
}

to FRACT_less a b {
  if (isType a 'number') {a = (FRACT a 1)}
  if (isType b 'number') {b = (FRACT b 1)}
  local 'lcd' ((FRACT_denominator a) * (FRACT_denominator b))
  return (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) < ((FRACT_numerator b) * (lcd / (FRACT_denominator b))))
}

to FRACT_multiply a b {
  if (isType a 'number') {a = (FRACT a 1)}
  if (isType b 'number') {b = (FRACT b 1)}
  return (FRACT_simplify (FRACT ((FRACT_numerator a) * (FRACT_numerator b)) ((FRACT_denominator a) * (FRACT_denominator b))))
}

to FRACT_numerator fraction {
  if (isType fraction 'number') {return fraction}
  return (at 1 fraction)
}

to FRACT_simplify fraction {
  if (isType fraction 'number') {return fraction}
  local 'gcd' (FRACT_gcd (FRACT_numerator fraction) (FRACT_denominator fraction))
  local 'simple' (FRACT ((FRACT_numerator fraction) / gcd) ((FRACT_denominator fraction) / gcd))
  if ((FRACT_denominator simple) == 1) {
    return (FRACT_numerator simple)
  }
  return simple
}

to FRACT_subtract a b {
  if (isType a 'number') {a = (FRACT a 1)}
  if (isType b 'number') {b = (FRACT b 1)}
  local 'lcd' ((FRACT_denominator a) * (FRACT_denominator b))
  return (FRACT_simplify (FRACT (((FRACT_numerator a) * (lcd / (FRACT_denominator a))) - ((FRACT_numerator b) * (lcd / (FRACT_denominator b)))) lcd))
}

