module Motion
variables _motionSamples _stepCount _stepThreshold _stepMotionHigh

	spec 'r' 'motion' 'motion'
	spec ' ' 'startStepCounter' 'start step counter'
	spec 'r' 'stepCount' 'step count'
	spec ' ' 'clearStepCount' 'clear step count'
	spec ' ' 'setStepThreshold' 'set step threshold _ (0-50)' 'auto' 10
	spec ' ' '_addSample' '_addSample _' 'auto' '10'
	spec 'r' '_recentAverage' '_recentAverage'
	spec ' ' '_stepCounterLoop' '_stepCounterLoop'

to '_addSample' s {
  if (0 == _motionSamples) {_motionSamples = (newArray 12)}
  for i ((size _motionSamples) - 1) {
    atPut i _motionSamples (at (i + 1) _motionSamples)
  }
  atPut (size _motionSamples) _motionSamples s
}

to '_recentAverage' {
  if (0 == _motionSamples) {return 0}
  local 'count' (size _motionSamples)
  local 'total' 0
  for i count {
    total += (at i _motionSamples)
  }
  return (total / count)
}

to '_stepCounterLoop' {
  if (_stepThreshold == 0) {_stepThreshold = 15}
  forever {
    local 'n' (motion)
    if (n > _stepThreshold) {
      if (not _stepMotionHigh) {
        _stepMotionHigh = (booleanConstant true)
        _stepCount += 1
        sendBroadcastSimple 'step'
      }
    } (n < -3) {
      _stepMotionHigh = (booleanConstant false)
    }
    waitMillis 10
  }
}

to clearStepCount {
  _stepCount = 0
}

to motion {
  comment 'Return the change in acceleration since the last call.'
  comment 'Details: The value is the difference between the current
total acceleration in all three axes and the average value
of the last N samples. Since we don''t have a square root
function, the total acceleration is computed as the sum of
the absolute values of the acceleration in all three axes.
The result is zero when there are no changes of acceleration.
It goes positive momentarily when the acceleration decreases
(e.g. because the microcontroller is dropped) and positive
when the acceleration increases (e.g. when a falling micro-
controller is caught).'
  local 'current' (absoluteValue (maximum (absoluteValue ('[sensors:tiltX]')) (absoluteValue ('[sensors:tiltY]')) (absoluteValue ('[sensors:tiltZ]'))))
  local 'result' (current - ('_recentAverage'))
  '_addSample' current
  if ((absoluteValue result) < 3) {
    comment 'Suppress sensor noise'
    result = 0
  }
  return result
}

to setStepThreshold threshold {
  comment 'The lower the threshold, the more sensitive the
step counter is. If the threshold is too low, it will
count extra steps. If it is too high, it will miss steps.'
  _stepThreshold = (threshold + 5)
}

to startStepCounter {
  comment 'Reset the step count to zero and start the
step counter loop.'
  _stepCount = 0
  sendBroadcastSimple '_stepCounterLoop'
}

to stepCount {
  return _stepCount
}

